"""
bodoque_clue_style.py
Prototipo avanzado estilo "Clue/Among-Us" en Pygame para el caso: ¿Quién mató a Juan Carlos Bodoque?

Versión 900x600 - Mapa centrado, texto ajustado, fondos, paleta gris estética.
Historial de Sospechosos e Imágenes de Locación.
"""
import pygame
import random
import textwrap
import sys
import math
import os
from collections import deque

pygame.init()
# -------------------------
# Configuración
# -------------------------
WIDTH, HEIGHT = 900, 600
SCREEN = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Bodoque — Clue-style (900x600)")
CLOCK = pygame.time.Clock()
FPS = 60

# Fuentes
try:
    font_path = "bbh_sans_bogle.ttf" # Si está en la misma carpeta

    FONT_BIG = pygame.font.Font(font_path, 32)
    FONT_MED = pygame.font.Font(font_path, 20)
    FONT_SM = pygame.font.Font(font_path, 15)
    FONT_XS = pygame.font.Font(font_path, 13)

except pygame.error as e:
    print(f"Error al cargar la fuente '{font_path}': {e}. Usando fuente por defecto.")
    FONT_BIG = pygame.font.Font(None, 40)
    FONT_MED = pygame.font.Font(None, 28)
    FONT_SM = pygame.font.Font(None, 22)
    FONT_XS = pygame.font.Font(None, 18)
except FileNotFoundError:
    print(f"Error: No se encontró el archivo de fuente '{font_path}'. Usando fuente por defecto.")
    FONT_BIG = pygame.font.Font(None, 40)
    FONT_MED = pygame.font.Font(None, 28)
    FONT_SM = pygame.font.Font(None, 22)
    FONT_XS = pygame.font.Font(None, 18)


# -------------------------
# --- Cargar Imágenes de Fondo y Convertir a Escala de Grises ---
# -------------------------
def convert_to_grayscale(surface):
    grayscale_surface = pygame.Surface(surface.get_size(), 0, 32).convert_alpha()
    grayscale_surface.blit(surface, (0, 0))

    for x in range(surface.get_width()):
        for y in range(surface.get_height()):
            r, g, b, a = surface.get_at((x, y))
            gray = int(0.2989 * r + 0.5870 * g + 0.1140 * b)
            grayscale_surface.set_at((x, y), (gray, gray, gray, a))
    return grayscale_surface

# Imagen para la pantalla de INTRODUCCIÓN
try:
    image_path_intro = os.path.join("Imagenes", "fondo.png")
    fondo_original_intro = pygame.image.load(image_path_intro).convert_alpha()
    FONDO_INTRO = pygame.transform.scale(fondo_original_intro, (WIDTH, HEIGHT))
    # FONDO_INTRO = convert_to_grayscale(FONDO_INTRO) # Descomenta para grises
except pygame.error as e:
    print(f"Error al cargar la imagen '{image_path_intro}': {e}")
    FONDO_INTRO = pygame.Surface((WIDTH, HEIGHT)); FONDO_INTRO.fill((46, 46, 46))
except FileNotFoundError as e:
    print(f"Error: No se encontró '{image_path_intro}'. {e}")
    FONDO_INTRO = pygame.Surface((WIDTH, HEIGHT)); FONDO_INTRO.fill((46, 46, 46))

# Imagen para el MENÚ PRINCIPAL
try:
    image_path_menu = os.path.join("Imagenes", "bodoque.jpg")
    fondo_original_menu = pygame.image.load(image_path_menu).convert_alpha()
    FONDO_MENU = pygame.transform.scale(fondo_original_menu, (WIDTH, HEIGHT))
    # FONDO_MENU = convert_to_grayscale(FONDO_MENU) # Descomenta para grises
except pygame.error as e:
    print(f"Error al cargar la imagen '{image_path_menu}': {e}")
    FONDO_MENU = pygame.Surface((WIDTH, HEIGHT)); FONDO_MENU.fill((46, 46, 46))
except FileNotFoundError as e:
    print(f"Error: No se encontró '{image_path_menu}'. {e}")
    FONDO_MENU = pygame.Surface((WIDTH, HEIGHT)); FONDO_MENU.fill((46, 46, 46))

# -------------------------
# --- Paleta de Colores (Fondo Oscuro, Elementos Claros) ---
# -------------------------
BG = (46, 46, 46)             # 6 Gris grafito (#2E2E2E) - Fondo principal (oscuro)
PANEL = (74, 74, 74)          # 5 Gris oscuro (#4A4A4A) - Paneles (ligeramente más claro)
CARD = (128, 128, 128)        # 4 Gris acero (#808080) - Botones secundarios, tarjetas (más claro)
ACCENT = (224, 224, 224)      # 2 Gris claro (#E0E0E0) - Acentos, botones activos (claro)
ACCENT_HOVER = (245, 245, 245) # 1 Gris muy claro (#F5F5F5) - Hover (muy claro)
OK = (224, 224, 224)          # 2 Gris claro (#E0E0E0) - Botones OK/Comenzar (claro)
BAD = (176, 176, 176)         # 3 Gris medio (#B0B0B0) - Botones Fallo/Acusar (distinto de OK, más claro que Card)
TEXT = (255, 255, 255)        # 0 Blanco puro (#FFFFFF) - Texto principal (muy claro)
MUTED = (176, 176, 176)       # 3 Gris medio (#B0B0B0) - Texto secundario (más claro)
SHADOW = (0, 0, 0)            # 7 Negro puro (#000000) - Sombras, texto sobre muy claro
NEGRO_PURO = (0, 0, 0)        # 7 Negro puro (#000000)


# -------------------------
# Datos del juego
# -------------------------
PERSONAJES = [
    "Tulio Triviño", # El jugador
    "Juanín Juan Harry",
    "Policarpo Avendaño",
    "Patana Tufillo",
    "Mario Hugo",
    "Mico el Micrófono"
]

SOSPECHOSOS = [p for p in PERSONAJES if p != "Tulio Triviño"] # Lista sin el jugador

LOCACIONES = [
    "Estudio Principal",
    "Sala de Guiones",
    "Cuarto de Iluminación",
    "Bodega de Utilería",
    "Set de Entrevistas"
]

ARMAS = [
    "Micrófono de Hierro",
    "Cable Eléctrico Pelado",
    "Estatua del Topo Gigio",
    "Guión Envenenado",
    "Tijeras de Escenografía"
]

CASOS = [
    {
        "nombre": "La Transmisión Final",
        "culpable": "Policarpo Avendaño",
        "arma": "Micrófono de Hierro",
        "locacion": "Estudio Principal",
        "motivo": "Policarpo acumuló rabia por años y en un arrebato golpeó a Bodoque con el micrófono.",
        "pista_clave": "Marcas metálicas en el piso y un camarógrafo dice haber visto a Policarpo limpiándose las manos en la cortina.",
        "pistas_falsas": {
            "Sala de Guiones": "Juanín revisaba horarios y murmuraba 'teníamos que corregirlo'.",
            "Cuarto de Iluminación": "Mico ajustaba focos; aseguró 'todo estaba bajo control'.",
            "Bodega de Utilería": "Mario Hugo movía cajas con prisa.",
            "Set de Entrevistas": "Patana buscaba silencio; parecía disgustada."
        }
    },
    {
        "nombre": "El Guión Mortal",
        "culpable": "Patana Tufillo",
        "arma": "Guión Envenenado",
        "locacion": "Sala de Guiones",
        "motivo": "Patana roció un guión con toxinas tras constantes humillaciones a su trabajo.",
        "pista_clave": "Guión manchado con olor químico; Mico vio a Patana dejar un paquete junto a la taza de Bodoque.",
        "pistas_falsas": {
            "Estudio Principal": "Policarpo limpiaba algo y susurraba con el camarógrafo.",
            "Cuarto de Iluminación": "Mico con guantes ajustando un foco.",
            "Bodega de Utilería": "Juanín dejó caer una caja con fuerza.",
            "Set de Entrevistas": "Mario murmuró 'otra vez esa broma' mientras ensayaba."
        }
    },
    {
        "nombre": "La Luz del Crimen",
        "culpable": "Mico el Micrófono",
        "arma": "Cable Eléctrico Pelado",
        "locacion": "Cuarto de Iluminación",
        "motivo": "Mico manipuló un cable para provocar un accidente temiendo ser descubierto.",
        "pista_clave": "Consola chamuscada, cable pelado y huella con carbón. Juanín lo vio toqueteando fusibles.",
        "pistas_falsas": {
            "Estudio Principal": "Lente empañado; Mario tosiendo aquí.",
            "Sala de Guiones": "Patana dejó una nota con el nombre de Bodoque tachado.",
            "Bodega de Utilería": "Policarpo guardaba algo envuelto en tela.",
            "Set de Entrevistas": "Taza de café derramada recogida por Tulio."
        }
    },
    {
        "nombre": "El Secreto en la Bodega",
        "culpable": "Juanín Juan Harry",
        "arma": "Tijeras de Escenografía",
        "locacion": "Bodega de Utilería",
        "motivo": "Juanín desviaba fondos y fue descubierto; en el forcejeo usó tijeras grandes.",
        "pista_clave": "Rastro de tela hasta caja con sangre. Tijeras ausentes. Mario oyó a Juanín gritar.",
        "pistas_falsas": {
            "Estudio Principal": "Tulio practicando su entrada, temblando.",
            "Sala de Guiones": "Patana dejó una pluma; mirada pensativa.",
            "Cuarto de Iluminación": "Mico apagó las luces con prisa.",
            "Set de Entrevistas": "Policarpo reacomodó sillas evitando mirarte."
        }
    },
    {
        "nombre": "La Entrevista que Mató",
        "culpable": "Mario Hugo",
        "arma": "Estatua del Topo Gigio",
        "locacion": "Set de Entrevistas",
        "motivo": "Mario, humillado en cámara, lo golpeó con la estatua en un arrebato.",
        "pista_clave": "Estatua rota con manchas. Cámara registró sombras violentas. Utilero oyó el golpe.",
        "pistas_falsas": {
            "Estudio Principal": "Gota de sudor junto al micrófono; Tulio nervioso.",
            "Sala de Guiones": "Guión plegado con correcciones rápidas.",
            "Cuarto de Iluminación": "Foco fuera de su lugar; Mico lo comentó.",
            "Bodega de Utilería": "Disfraz con mancha oscura reciente."
        }
    }
]

# -------------------------
# --- Datos de Sospechosos ---
# -------------------------
SUSPECT_DATA = {
    "Juanín Juan Harry": {
        "historia": "Juanín siempre admiró la habilidad de Bodoque para conseguir exclusivas, pero secretamente envidiaba su protagonismo. Recientemente, Bodoque descubrió un error grave en las cuentas que manejaba Juanín...",
        "imagen": "Juanin_Juan_Harry.png"
    },
    "Policarpo Avendaño": {
        "historia": "Policarpo y Bodoque competían constantemente por el 'Top Top Top' de la popularidad. Policarpo sentía que Bodoque le robaba ideas para sus notas verdes, lo que generó una fuerte discusión la noche anterior.",
        "imagen": "Policarpo_Avendano.png"
    },
    "Patana Tufillo": {
        "historia": "Patana, la eterna practicante, estaba cansada de que Bodoque se burlara de sus intentos de reportajes serios. Él le había prometido ayudarla a ascender, pero siempre terminaba ridiculizándola en cámara.",
        "imagen": "Patana_Tufillo.png"
    },
    "Mario Hugo": {
        "historia": "Mario Hugo respetaba a Bodoque, pero odiaba cuando este exponía sus despistes amorosos en público. La última broma de Bodoque sobre él en el noticiero lo dejó profundamente humillado.",
        "imagen": "Mario_Hugo.png"
    },
    "Mico el Micrófono": {
        "historia": "Mico, el técnico de sonido, tenía una deuda pendiente con Bodoque por un viejo 'favor'. Bodoque lo estaba presionando para que le diera información confidencial del canal, amenazando con revelar su secreto.",
        "imagen": "Mico_el_Microfono.png"
    }
}

# Cargar imágenes de sospechosos
SUSPECT_IMAGES = {}
for name, data in SUSPECT_DATA.items():
    try:
        img_path = os.path.join("Imagenes", data["imagen"])
        original_img = pygame.image.load(img_path).convert_alpha()
        scaled_img = pygame.transform.scale(original_img, (150, 150))
        # scaled_img = convert_to_grayscale(scaled_img) # Descomenta para grises
        SUSPECT_IMAGES[name] = scaled_img
    except Exception as e:
        print(f"Error al cargar imagen para {name}: {e}")
        SUSPECT_IMAGES[name] = None


# -------------------------
# --- Cargar Imágenes de Locaciones y Logo ---
# -------------------------
LOCATION_IMAGES_FILES = {
    "Estudio Principal": "estudio.jpg",
    "Sala de Guiones": "guiones.jpg",
    "Cuarto de Iluminación": "iluminacion.jpg",
    "Bodega de Utilería": "utileria.png",
    "Set de Entrevistas": "entrevistas.png"
}

LOCATION_IMAGES = {}
LOCATION_IMAGE_SIZE = (WIDTH // 3, HEIGHT // 4)

for name, filename in LOCATION_IMAGES_FILES.items():
    try:
        img_path = os.path.join("Imagenes", filename)
        original_img = pygame.image.load(img_path).convert_alpha()
        scaled_img = pygame.transform.scale(original_img, LOCATION_IMAGE_SIZE)
        # scaled_img = convert_to_grayscale(scaled_img) # Descomenta para grises
        LOCATION_IMAGES[name] = scaled_img
    except Exception as e:
        print(f"Error al cargar imagen para locación {name}: {e}")
        LOCATION_IMAGES[name] = None

# Cargar Logo (para el panel derecho por defecto)
try:
    logo_path = os.path.join("Imagenes", "logo.png")
    LOGO_IMG = pygame.image.load(logo_path).convert_alpha()
    LOGO_IMG = pygame.transform.scale(LOGO_IMG, (300, 300))
except Exception as e:
    print(f"Error al cargar logo.png: {e}")
    LOGO_IMG = None


# -------------------------
# Estructura del "tablero"
# -------------------------
ROOM_LABELS = {
    "Estudio Principal": ["Estudio", "Principal"],
    "Sala de Guiones": ["Sala de", "Guiones"],
    "Cuarto de Iluminación": ["Cuarto de", "Iluminación"],
    "Bodega de Utilería": ["Bodega de", "Utilería"],
    "Set de Entrevistas": ["Set de", "Entrevistas"]
}
ROOM_POS_PERCENT = {
    "Estudio Principal":      (0.5, 0.5),
    "Sala de Guiones":        (0.5, 0.2),
    "Cuarto de Iluminación": (0.2, 0.5),
    "Bodega de Utilería":     (0.5, 0.8),
    "Set de Entrevistas":     (0.8, 0.5)
}
ROOM_RADIUS = 55
ROOM_EDGES = [
    ("Estudio Principal", "Sala de Guiones"), ("Estudio Principal", "Cuarto de Iluminación"),
    ("Estudio Principal", "Bodega de Utilería"), ("Estudio Principal", "Set de Entrevistas"),
    ("Sala de Guiones", "Set de Entrevistas"), ("Set de Entrevistas", "Bodega de Utilería"),
    ("Bodega de Utilería", "Cuarto de Iluminación"), ("Cuarto de Iluminación", "Sala de Guiones")
]

SECRET_CASE = random.choice(CASOS)
SOLUTION = {
    'culpable': SECRET_CASE['culpable'], 'arma': SECRET_CASE['arma'], 'locacion': SECRET_CASE['locacion']
}

# -------------------------
# Estado del juego
# -------------------------
state = {
    'screen': 'main_menu',
    'turns': 5,
    'evidence': [],
    'investigated': set(),
    'selected_room': None,
    'selected_suspect': None,
    'accuse_choice': {'person': None, 'weapon': None, 'room': None},
    'result': None,
    'show_map': True # Estado inicial para mostrar el mapa al iniciar la pantalla 'board'
}

# -------------------------
# Utilities UI
# -------------------------
def draw_text(surf, text, pos, font=FONT_MED, color=TEXT, center=False, v_center=False):
    txt = font.render(text, True, color)
    rect = txt.get_rect()
    if center: rect.centerx = pos[0]
    else: rect.x = pos[0]
    if v_center: rect.centery = pos[1]
    else: rect.y = pos[1]
    if center and v_center: rect.center = pos
    surf.blit(txt, rect)
    return rect

def rounded_rect(surface, rect, color, radius=10):
    pygame.draw.rect(surface, color, rect, border_radius=radius)

def draw_shadowed_panel(surface, rect, color=PANEL, shadow_offset=6):
    shadow_rect = rect.move(shadow_offset, shadow_offset)
    rounded_rect(surface, shadow_rect, SHADOW)
    rounded_rect(surface, rect, color, radius=10)

def wrap_para(text, width, font):
    words = text.split(' ')
    lines, cur = [], ''
    for w in words:
        test = cur + (' ' if cur else '') + w
        if font.size(test)[0] > width:
            lines.append(cur); cur = w
        else: cur = test
    if cur: lines.append(cur)
    return lines

# -------------------------
# Draw screens
# -------------------------
def screen_main_menu():
    SCREEN.blit(FONDO_MENU, (0, 0))
    overlay = pygame.Surface((WIDTH, HEIGHT)); overlay.set_alpha(180); overlay.fill(BG); SCREEN.blit(overlay, (0, 0))
    draw_text(SCREEN, "¿QUIÉN MATÓ A JUAN CARLOS BODOQUE?", (WIDTH // 2, HEIGHT // 3), FONT_BIG, NEGRO_PURO, center=True)
    btn_rect = pygame.Rect(WIDTH // 2 - 140, HEIGHT // 2, 280, 64); rounded_rect(SCREEN, btn_rect, OK)
    draw_text(SCREEN, "COMENZAR", btn_rect.center, FONT_MED, color=SHADOW, center=True, v_center=True)
    draw_text(SCREEN, "Presiona ESC para salir.", (WIDTH // 2, HEIGHT - 40), FONT_XS, MUTED, center=True)
    return btn_rect

def screen_intro():
    SCREEN.blit(FONDO_INTRO, (0, 0)) # Sin overlay
    draw_text(SCREEN, "LA HISTORIA HASTA AHORA...", (WIDTH // 2, 60), FONT_BIG, ACCENT, center=True)
    desc = ("Eres Tulio Triviño, el presentador/detective improvisado. La tormenta encierra al equipo "
            "en el canal. Investiga las locaciones, recoge evidencias y acusa antes de que se acaben los turnos.")
    lines = wrap_para(desc, WIDTH - 120, FONT_MED)
    y = 130
    for ln in lines: draw_text(SCREEN, ln, (WIDTH // 2, y), FONT_MED, SHADOW, center=True); y += 28
    btn_rect = pygame.Rect(WIDTH // 2 - 140, HEIGHT - 120, 280, 64); rounded_rect(SCREEN, btn_rect, OK)
    draw_text(SCREEN, "COMENZAR INVESTIGACIÓN", btn_rect.center, FONT_MED, color=SHADOW, center=True, v_center=True)
    draw_text(SCREEN, "Presiona ESC para salir.", (WIDTH // 2, HEIGHT - 40), FONT_XS, MUTED, center=True)
    return btn_rect

def screen_board(mouse_pos):
    SCREEN.fill(BG)
    left_panel_width = 240
    left = pygame.Rect(10, 10, left_panel_width, HEIGHT - 20)
    draw_shadowed_panel(SCREEN, left, color=PANEL)
    draw_text(SCREEN, "Menú del Caso", (left.x + 20, 26), FONT_MED, ACCENT)
    draw_text(SCREEN, f"Turnos restantes: {state['turns']}", (left.x + 20, 62), FONT_SM, TEXT)
    draw_text(SCREEN, "Acciones:", (left.x + 20, 100), FONT_SM, MUTED)
    btn_width, btn_y_start, btn_y_gap = left_panel_width - 40, 130, 50
    btn_invest = pygame.Rect(left.x + 20, btn_y_start, btn_width, 40); rounded_rect(SCREEN, btn_invest, ACCENT)
    draw_text(SCREEN, "Investigar locación", btn_invest.center, FONT_SM, SHADOW, center=True, v_center=True)
    btn_inv = pygame.Rect(left.x + 20, btn_y_start + btn_y_gap, btn_width, 40); rounded_rect(SCREEN, btn_inv, CARD)
    draw_text(SCREEN, "Ver inventario", btn_inv.center, FONT_SM, TEXT, center=True, v_center=True)
    btn_suspects = pygame.Rect(left.x + 20, btn_y_start + 2*btn_y_gap, btn_width, 40); rounded_rect(SCREEN, btn_suspects, CARD)
    draw_text(SCREEN, "Ver Sospechosos", btn_suspects.center, FONT_SM, TEXT, center=True, v_center=True)
    btn_acc = pygame.Rect(left.x + 20, btn_y_start + 3*btn_y_gap, btn_width, 40); rounded_rect(SCREEN, btn_acc, BAD)
    draw_text(SCREEN, "Hacer acusación", btn_acc.center, FONT_SM, TEXT, center=True, v_center=True)
    draw_text(SCREEN, "(Click en una locación)", (left.x + 20, btn_y_start + 4*btn_y_gap + 10), FONT_XS, MUTED)
    map_x_start = left.right + 10
    map_rect = pygame.Rect(map_x_start, 10, WIDTH - map_x_start - 10, HEIGHT - 20)
    draw_shadowed_panel(SCREEN, map_rect, color=PANEL)
    absolute_room_pos = {}
    hover_room = None
    
    # Lógica de dibujo del mapa o el logo
    if state.get("show_map", True):
        draw_text(SCREEN, "Mapa del Set", (map_rect.x + 16, map_rect.y + 10), FONT_MED, ACCENT)
        for name, (rel_x, rel_y) in ROOM_POS_PERCENT.items():
            padding_x, padding_y = 40, 30
            panel_w_padded, panel_h_padded = map_rect.width - (padding_x * 2), map_rect.height - (padding_y * 2)
            abs_x = map_rect.x + padding_x + (panel_w_padded * rel_x); abs_y = map_rect.y + padding_y + (panel_h_padded * rel_y)
            absolute_room_pos[name] = (abs_x, abs_y)
        for a,b in ROOM_EDGES:
            ax, ay = absolute_room_pos[a]; bx, by = absolute_room_pos[b]
            pygame.draw.line(SCREEN, MUTED, (ax, ay), (bx, by), 3)
        
        for name, pos in absolute_room_pos.items():
            x,y = pos; r = ROOM_RADIUS; dist = math.hypot(mouse_pos[0]-x, mouse_pos[1]-y); hovered = dist <= r
            color = ACCENT if name not in state['investigated'] else CARD
            if hovered: color = ACCENT_HOVER; hover_room = name
            pygame.draw.circle(SCREEN, color, (int(x), int(y)), r); pygame.draw.circle(SCREEN, SHADOW, (int(x), int(y)), r, 4)
            lines = ROOM_LABELS.get(name, [name]); line_height = FONT_XS.get_linesize() * 0.9; total_text_height = len(lines) * line_height
            start_y = y - (total_text_height / 2) + (line_height / 2); current_y = start_y
            for line in lines: draw_text(SCREEN, line, (x, current_y), FONT_XS, SHADOW, center=True, v_center=True); current_y += line_height
        
        # Mostrar Tooltip de Sala
        if hover_room:
            # Asegurar que el tooltip no se salga de la pantalla
            box_x = mouse_pos[0] + 12
            box_y = mouse_pos[1] + 12
            
            # Ancho y alto fijos para el tooltip
            box_width = 260
            box_height = 80
            
            # Ajustar si se sale por la derecha
            if box_x + box_width > WIDTH - 10:
                box_x = mouse_pos[0] - 12 - box_width
            
            # Ajustar si se sale por abajo
            if box_y + box_height > HEIGHT - 10:
                box_y = mouse_pos[1] - 12 - box_height
                
            box = pygame.Rect(box_x, box_y, box_width, box_height)
            
            rounded_rect(SCREEN, box, PANEL)
            
            # Contenido del tooltip
            if hover_room == SECRET_CASE['locacion']:
                tip = "Aquí hay algo importante... (clic para investigar)"
            else:
                tip = "Investigar: podrás encontrar observaciones o pistas falsas."
                
            draw_text(SCREEN, hover_room, (box.x + 12, box.y + 8), FONT_SM, ACCENT)
            lines = wrap_para(tip, box.width - 24, FONT_XS); ly = box.y + 34
            for ln in lines: draw_text(SCREEN, ln, (box.x + 12, ly), FONT_XS, TEXT); ly += 18
            
        ev_y_start = map_rect.y + map_rect.height - 130

        draw_text(SCREEN, "Evidencias (últimas):", (map_rect.x + 16, ev_y_start), FONT_SM, MUTED)
        y = ev_y_start + 30
        for e in state['evidence'][-3:]: draw_text(SCREEN, f"• [{e['loc']}] {e['text'][:35]}...", (map_rect.x + 26, y), FONT_XS, TEXT); y += 22
        
    else:
        # Mostrar el logo si no está en modo mapa
        if LOGO_IMG:
            logo_rect = LOGO_IMG.get_rect(center=map_rect.center)
            SCREEN.blit(LOGO_IMG, logo_rect)
        else:
            draw_text(SCREEN, "Logo no disponible", (map_rect.centerx, map_rect.centery), FONT_MED, TEXT, center=True, v_center=True)

    draw_text(SCREEN, "Prototipo Pygame", (20, HEIGHT-24), FONT_XS, MUTED)
    return btn_invest, btn_inv, btn_acc, hover_room, absolute_room_pos, btn_suspects

def screen_suspect_list():
    SCREEN.fill(BG)
    panel_rect = pygame.Rect(50, 50, WIDTH - 100, HEIGHT - 100)
    draw_shadowed_panel(SCREEN, panel_rect, color=PANEL)
    draw_text(SCREEN, "Historial de Sospechosos", (panel_rect.centerx, panel_rect.y + 30), FONT_BIG, ACCENT, center=True)
    buttons = []; button_width, button_height, start_y, gap = panel_rect.width - 100, 50, panel_rect.y + 100, 15
    for i, suspect_name in enumerate(SOSPECHOSOS):
        y_pos = start_y + i * (button_height + gap)
        btn_rect = pygame.Rect(panel_rect.centerx - button_width // 2, y_pos, button_width, button_height)
        rounded_rect(SCREEN, btn_rect, CARD)
        draw_text(SCREEN, suspect_name, btn_rect.center, FONT_MED, TEXT, center=True, v_center=True)
        buttons.append((suspect_name, btn_rect))
    btn_back_rect = pygame.Rect(panel_rect.x + 30, panel_rect.bottom - 70, 120, 40); rounded_rect(SCREEN, btn_back_rect, CARD)
    draw_text(SCREEN, "Volver", btn_back_rect.center, FONT_MED, TEXT, center=True, v_center=True)
    buttons.append(("volver", btn_back_rect))
    return buttons

def screen_suspect_detail(suspect_name):
    SCREEN.fill(BG)
    panel_rect = pygame.Rect(50, 50, WIDTH - 100, HEIGHT - 100)
    draw_shadowed_panel(SCREEN, panel_rect, color=PANEL)
    draw_text(SCREEN, suspect_name, (panel_rect.centerx, panel_rect.y + 30), FONT_BIG, ACCENT, center=True)
    data, image = SUSPECT_DATA.get(suspect_name), SUSPECT_IMAGES.get(suspect_name)
    img_width, img_height = 150, 150 # Definir tamaño aquí
    
    # 1. Dibujar Imagen o Placeholder
    if image:
        img_rect = image.get_rect(topright=(panel_rect.right - 30, panel_rect.y + 80))
        SCREEN.blit(image, img_rect)
    else:
        img_rect = pygame.Rect(panel_rect.right - 30 - img_width, panel_rect.y + 80, img_width, img_height)
        rounded_rect(SCREEN, img_rect, CARD)
        draw_text(SCREEN, "(Sin Imagen)", img_rect.center, FONT_SM, TEXT, center=True, v_center=True)
        
    # 2. Dibujar Historia
    if data:
        story_text = data.get("historia", "Sin información disponible.")
        text_width = panel_rect.width - 60 - img_width - 20 # Ancho total - padding - ancho imagen - espacio
        lines = wrap_para(story_text, text_width, FONT_SM)
        start_y, x_pos, line_gap, current_y = panel_rect.y + 100, panel_rect.x + 30, FONT_SM.get_linesize() * 1.2, start_y
        for line in lines:
            draw_text(SCREEN, line, (x_pos, current_y), FONT_SM, TEXT)
            current_y += line_gap
            if current_y > panel_rect.bottom - 80: draw_text(SCREEN, "...", (x_pos, current_y), FONT_SM, TEXT); break
            
    # 3. Botón de Volver
    btn_back_rect = pygame.Rect(panel_rect.x + 30, panel_rect.bottom - 70, 120, 40); rounded_rect(SCREEN, btn_back_rect, CARD)
    draw_text(SCREEN, "Volver", btn_back_rect.center, FONT_MED, TEXT, center=True, v_center=True)
    return btn_back_rect

def screen_investigate(room):
    SCREEN.fill(BG)
    panel = pygame.Rect(40, 30, WIDTH - 80, HEIGHT - 60)
    draw_shadowed_panel(SCREEN, panel, color=PANEL)
    draw_text(SCREEN, f"Investigando: {room}", (panel.centerx, panel.y + 20), FONT_BIG, ACCENT, center=True)
    sub = "Observa: aquí verás quién estuvo y qué hizo. Si es la locación del caso, aparecerá la PISTA CLAVE."
    lines = wrap_para(sub, panel.width - 40, FONT_SM)
    text_y_start = panel.y + 64; ly = text_y_start
    for ln in lines: draw_text(SCREEN, ln, (panel.centerx, ly), FONT_SM, MUTED, center=True); ly += 22
    
    # Área de Texto y Área de Imagen
    text_area_height = (panel.height - (ly - panel.y) - 80) * 0.5
    text_area_top = ly + 10
    image_area_top = text_area_top + text_area_height + 10
    image_area_height = panel.height - (image_area_top - panel.y) - 70
    
    # Contenido de la pista
    content = "PISTA CLAVE: " + SECRET_CASE['pista_clave'] if room == SECRET_CASE['locacion'] else "OBSERVACIÓN: " + SECRET_CASE['pistas_falsas'].get(room, "Solo polvo y silencio; nadie relevante estuvo aquí.")
    
    # Dibujar Pista
    text_lines = wrap_para(content, panel.width - 60, FONT_SM); text_ly = text_area_top; line_gap = FONT_SM.get_linesize() * 1.1
    for ln in text_lines:
        if text_ly < image_area_top - line_gap: draw_text(SCREEN, ln, (panel.x + 30, text_ly), FONT_SM, TEXT); text_ly += line_gap
        else: draw_text(SCREEN, "...", (panel.x + 30, text_ly), FONT_SM, TEXT); break
        
    # Dibujar Imagen de Locación
    location_image = LOCATION_IMAGES.get(room)
    if location_image:
        img_rect = location_image.get_rect(centerx=panel.centerx, top=image_area_top)
        
        # Ajuste de escala si la imagen es muy grande
        if img_rect.height > image_area_height:
             scale_factor = image_area_height / img_rect.height; new_width = int(img_rect.width * scale_factor)
             location_image = pygame.transform.smoothscale(location_image, (new_width, int(image_area_height)))
             img_rect = location_image.get_rect(centerx=panel.centerx, top=image_area_top)
             
        img_rect.top = max(img_rect.top, image_area_top); img_rect.bottom = min(img_rect.bottom, panel.bottom - 70)
        SCREEN.blit(location_image, img_rect)
    else:
        # Placeholder de imagen
        img_placeholder_rect = pygame.Rect(0, 0, LOCATION_IMAGE_SIZE[0], LOCATION_IMAGE_SIZE[1])
        img_placeholder_rect.centerx = panel.centerx; img_placeholder_rect.top = image_area_top
        rounded_rect(SCREEN, img_placeholder_rect, CARD)
        draw_text(SCREEN, "(Sin Imagen)", img_placeholder_rect.center, FONT_SM, TEXT, center=True, v_center=True)
        
    # Botones
    btn_take = pygame.Rect(panel.x + panel.width - 200, panel.y + panel.height - 60, 160, 40); rounded_rect(SCREEN, btn_take, ACCENT)
    draw_text(SCREEN, "Guardar evidencia", btn_take.center, FONT_MED, SHADOW, center=True, v_center=True)
    btn_back = pygame.Rect(panel.x + 24, panel.y + panel.height - 60, 120, 40); rounded_rect(SCREEN, btn_back, CARD)
    draw_text(SCREEN, "Volver", btn_back.center, FONT_MED, TEXT, center=True, v_center=True)
    draw_text(SCREEN, f"Turnos: {state['turns']}", (panel.x + panel.width - 100, panel.y + 20), FONT_SM, MUTED, center=True)
    
    return btn_take, btn_back, content

def screen_inventory():
    SCREEN.fill(BG)
    rect = pygame.Rect(30, 30, WIDTH - 60, HEIGHT - 60); draw_shadowed_panel(SCREEN, rect, color=PANEL)
    draw_text(SCREEN, "Inventario de Evidencias", (rect.centerx, rect.y + 16), FONT_BIG, ACCENT, center=True)
    
    if not state['evidence']:
        draw_text(SCREEN, "No has recolectado evidencia aún.", (rect.centerx, rect.y + 80), FONT_MED, MUTED, center=True)
    else:
        y = rect.y + 72
        for i, ev in enumerate(state['evidence'], start=1):
            box = pygame.Rect(rect.x + 20, y, rect.width - 40, 60); rounded_rect(SCREEN, box, CARD)
            draw_text(SCREEN, f"{i}. [{ev['loc']}]", (box.x + 16, box.y + 8), FONT_SM, ACCENT)
            
            lines = wrap_para(ev['text'], box.width - 30, FONT_XS); ly = box.y + 28
            for ln in lines[:2]: draw_text(SCREEN, ln, (box.x + 16, ly), FONT_XS, TEXT); ly += 18
            
            y += 70
            if y > rect.y + rect.height - 80: break
            
    btn_back = pygame.Rect(rect.x + 20, rect.y + rect.height - 60, 120, 40); rounded_rect(SCREEN, btn_back, CARD)
    draw_text(SCREEN, "Volver", btn_back.center, FONT_MED, TEXT, center=True, v_center=True)
    return btn_back

def screen_accuse(selection):
    SCREEN.fill(BG)
    panel = pygame.Rect(30, 30, WIDTH - 60, HEIGHT - 60); draw_shadowed_panel(SCREEN, panel, color=PANEL)
    draw_text(SCREEN, "Acusación Final", (panel.centerx, panel.y + 16), FONT_BIG, ACCENT, center=True)
    draw_text(SCREEN, "Selecciona Sospechoso • Arma • Locación", (panel.centerx, panel.y + 60), FONT_SM, MUTED, center=True)
    
    # Configuración de Columnas
    col_gap = 10
    col_count = 3
    total_gap_width = col_gap * (col_count - 1)
    col_w = (panel.width - 40 - total_gap_width) / col_count # Ancho total - padding / 3
    col_x = [panel.x + 20, panel.x + 20 + col_w + col_gap, panel.x + 20 + 2*(col_w + col_gap)]
    
    button_height = 38
    button_spacing = 44 # 38 + 6

    # Columna 1: Sospechosos
    for i, p in enumerate(SOSPECHOSOS):
        rect = pygame.Rect(col_x[0], panel.y + 100 + i*button_spacing, col_w, button_height)
        color = ACCENT if selection['person']==i else CARD
        rounded_rect(SCREEN, rect, color)
        
        # Ajuste de fuente para textos largos
        font_to_use = FONT_SM if FONT_SM.size(f"{p}")[0] < col_w - 20 else FONT_XS
        text_color = SHADOW if selection['person']==i else TEXT
        draw_text(SCREEN, p, (rect.x+10, rect.centery), font_to_use, text_color, v_center=True)
        
    # Columna 2: Armas
    for i, a in enumerate(ARMAS):
        rect = pygame.Rect(col_x[1], panel.y + 100 + i*button_spacing, col_w, button_height)
        color = ACCENT if selection['weapon']==i else CARD
        rounded_rect(SCREEN, rect, color)
        
        font_to_use = FONT_SM if FONT_SM.size(f"{a}")[0] < col_w - 20 else FONT_XS
        text_color = SHADOW if selection['weapon']==i else TEXT
        draw_text(SCREEN, a, (rect.x+10, rect.centery), font_to_use, text_color, v_center=True)
        
    # Columna 3: Locaciones
    for i, l in enumerate(LOCACIONES):
        rect = pygame.Rect(col_x[2], panel.y + 100 + i*button_spacing, col_w, button_height)
        color = ACCENT if selection['room']==i else CARD
        rounded_rect(SCREEN, rect, color)
        
        font_to_use = FONT_SM if FONT_SM.size(f"{l}")[0] < col_w - 20 else FONT_XS
        text_color = SHADOW if selection['room']==i else TEXT
        draw_text(SCREEN, l, (rect.x+10, rect.centery), font_to_use, text_color, v_center=True)

    # Botón de Confirmar
    btn_confirm = pygame.Rect(panel.centerx - 120, panel.y + panel.height - 70, 240, 50)
    
    # Solo permitir confirmar si las 3 opciones están seleccionadas
    if selection['person'] is not None and selection['weapon'] is not None and selection['room'] is not None:
        button_color = BAD # O un color distintivo para Acusar
    else:
        button_color = CARD # Color deshabilitado
        
    rounded_rect(SCREEN, btn_confirm, button_color)
    draw_text(SCREEN, "Confirmar acusación", btn_confirm.center, FONT_MED, TEXT, center=True, v_center=True)
    
    # Evidencias
    ev_y_start = panel.y + panel.height - 140
    draw_text(SCREEN, "Evidencias disponibles:", (panel.centerx, ev_y_start), FONT_SM, MUTED, center=True)
    y = ev_y_start + 20
    for e in state['evidence'][-3:]: 
        txt = f"• [{e['loc']}] {e['text'][:30]}..."
        draw_text(SCREEN, txt, (panel.centerx, y), FONT_XS, TEXT, center=True)
        y += 20
        
    return btn_confirm

def screen_result(success, text):
    SCREEN.fill(BG)
    panel = pygame.Rect(40, 40, WIDTH - 80, HEIGHT - 80); draw_shadowed_panel(SCREEN, panel, color=PANEL)
    
    title = "¡CASO RESUELTO!" if success else "FALLASTE"
    color = OK if success else BAD
    
    draw_text(SCREEN, title, (panel.centerx, panel.y + 20), FONT_BIG, color, center=True)
    
    lines = wrap_para(text, panel.width - 60, FONT_MED)
    y = panel.y + 100
    for ln in lines: 
        draw_text(SCREEN, ln, (panel.centerx, y), FONT_MED, TEXT, center=True)
        y += 28
        
    btn_exit = pygame.Rect(panel.centerx - 120, panel.bottom - 70, 240, 50); rounded_rect(SCREEN, btn_exit, CARD)
    draw_text(SCREEN, "Salir", btn_exit.center, FONT_MED, TEXT, center=True, v_center=True)
    return btn_exit

# -------------------------
# Interaction helpers
# -------------------------
def investigate_room(room):
    # La lógica de consumir turno y añadir a 'investigated' se hará
    # cuando el jugador pulse 'Guardar evidencia' en la pantalla 'investigate'.
    
    # Generar la pista (temporalmente, la pista real se maneja en screen_investigate)
    text = "PISTA CLAVE: " + SECRET_CASE['pista_clave'] if room == SECRET_CASE['locacion'] else "OBSERVACIÓN: " + SECRET_CASE['pistas_falsas'].get(room, "Solo polvo y silencio; nadie relevante estuvo aquí.")
    return text

def complete_investigation(room, content):
    """Guarda la evidencia y consume un turno."""
    if room not in state['investigated']:
        state['investigated'].add(room)
        state['evidence'].append({'loc': room, 'text': content})
        state['turns'] -= 1
        return True
    return False

def evaluate_accusation(choice):
    """Evalúa la acusación final del jugador."""
    
    # 1. Verificar que todos los campos estén seleccionados
    if choice['person'] is None or choice['weapon'] is None or choice['room'] is None:
        return False, "Debes seleccionar un sospechoso, un arma y una locación."
    
    # 2. Obtener los nombres de las selecciones
    suspect = SOSPECHOSOS[choice['person']]
    weapon = ARMAS[choice['weapon']]
    room = LOCACIONES[choice['room']]
    
    # 3. Evaluar la acusación
    if suspect == SOLUTION['culpable'] and weapon == SOLUTION['arma'] and room == SOLUTION['locacion']:
        result_text = (f"¡Acusación correcta! El culpable es {suspect}, quien usó el {weapon} "
                      f"en {room}. El motivo: {SECRET_CASE['motivo']}")
        return True, result_text
    else:
        # Penalización: en Clue el juego termina si fallas
        state['turns'] = 0 
        result_text = (f"Acusación incorrecta. Señalaste a {suspect} con el {weapon} en {room}. "
                      f"El caso real era: {SOLUTION['culpable']}, {SOLUTION['arma']} en {SOLUTION['locacion']}."
                      f"¡El verdadero asesino escapó!")
        return False, result_text

# -------------------------
# Main Game Loop
# -------------------------
def main():
    # Inicialización de variables para evitar UnboundLocalError
    btn_inv = pygame.Rect(0, 0, 1, 1) 
    btn_acc = pygame.Rect(0, 0, 1, 1)
    btn_invest = pygame.Rect(0, 0, 1, 1)
    btn_suspects = pygame.Rect(0, 0, 1, 1)
    hover_room = None
    absolute_room_pos = {}
    current_investigation_content = "" # Para guardar el texto de la pista temporalmente
    
    running = True
    mouse_pos = (0, 0)

    while running:
        # Manejo de eventos
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    running = False
            elif event.type == pygame.MOUSEMOTION:
                mouse_pos = event.pos

            # Manejo de clics
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if state['screen'] == 'main_menu':
                    btn = screen_main_menu()
                    if btn.collidepoint(mouse_pos):
                        state['screen'] = 'intro'

                elif state['screen'] == 'intro':
                    btn = screen_intro()
                    if btn.collidepoint(mouse_pos):
                        state['screen'] = 'board'

                elif state['screen'] == 'board':
                    # Lógica de clic para los botones de la izquierda
                    if btn_inv.collidepoint(mouse_pos):
                        state['screen'] = 'inventory'
                        state['show_map'] = False
                    elif btn_suspects.collidepoint(mouse_pos):
                        state['screen'] = 'suspect_list'
                        state['show_map'] = False
                    elif btn_acc.collidepoint(mouse_pos):
                        state['screen'] = 'accuse'
                        state['show_map'] = False
                    elif btn_invest.collidepoint(mouse_pos):
                        state['show_map'] = True  # Mostrar el mapa si se presiona el botón

                    # Lógica de clic en el mapa para investigar (solo si el mapa está visible)
                    elif state['show_map'] and hover_room:
                        state['selected_room'] = hover_room
                        state['screen'] = 'investigate'
                
                elif state['screen'] == 'suspect_list':
                    buttons = screen_suspect_list()
                    for name, btn in buttons:
                        if btn.collidepoint(mouse_pos):
                            if name == "volver":
                                state['screen'] = 'board'
                                state['show_map'] = True # Volver al tablero
                            else:
                                state['screen'] = 'suspect_detail'
                                state['selected_suspect'] = name
                
                elif state['screen'] == 'suspect_detail':
                    btn = screen_suspect_detail(state['selected_suspect'])
                    if btn.collidepoint(mouse_pos):
                        state['screen'] = 'suspect_list'
                
                elif state['screen'] == 'investigate':
                    # Usamos los botones y el contenido de la última llamada a screen_investigate
                    btn_take, btn_back, content_temp = screen_investigate(state['selected_room'])
                    
                    if btn_back.collidepoint(mouse_pos):
                        state['screen'] = 'board'
                        state['show_map'] = True
                        
                    elif btn_take.collidepoint(mouse_pos):
                        # Guardar la evidencia y consumir el turno.
                        if complete_investigation(state['selected_room'], current_investigation_content):
                            state['screen'] = 'board'
                            state['show_map'] = True
                        else:
                            # Ya se investigó esta sala, podrías poner una alerta, 
                            # pero por ahora simplemente volvemos al tablero.
                            state['screen'] = 'board'
                            state['show_map'] = True


                elif state['screen'] == 'inventory':
                    btn = screen_inventory()
                    if btn.collidepoint(mouse_pos):
                        state['screen'] = 'board'
                        state['show_map'] = True
                
                elif state['screen'] == 'accuse':
                    btn_confirm = screen_accuse(state['accuse_choice'])
                    
                    # Clics en las 3 columnas
                    col_gap = 10; col_count = 3
                    total_gap_width = col_gap * (col_count - 1)
                    col_w = (WIDTH - 60 - total_gap_width) / col_count
                    col_x = [30 + 20, 30 + 20 + col_w + col_gap, 30 + 20 + 2*(col_w + col_gap)]
                    button_spacing = 44
                    
                    # Clics en Sospechosos
                    for i, p in enumerate(SOSPECHOSOS):
                        rect = pygame.Rect(col_x[0], 30 + 100 + i*button_spacing, col_w, 38)
                        if rect.collidepoint(mouse_pos): state['accuse_choice']['person'] = i
                        
                    # Clics en Armas
                    for i, a in enumerate(ARMAS):
                        rect = pygame.Rect(col_x[1], 30 + 100 + i*button_spacing, col_w, 38)
                        if rect.collidepoint(mouse_pos): state['accuse_choice']['weapon'] = i
                        
                    # Clics en Locaciones
                    for i, l in enumerate(LOCACIONES):
                        rect = pygame.Rect(col_x[2], 30 + 100 + i*button_spacing, col_w, 38)
                        if rect.collidepoint(mouse_pos): state['accuse_choice']['room'] = i

                    # Clic en Confirmar
                    if btn_confirm.collidepoint(mouse_pos):
                        success, text = evaluate_accusation(state['accuse_choice'])
                        state['result'] = (success, text)
                        state['screen'] = 'result'

                elif state['screen'] == 'result':
                    btn_exit = screen_result(*state['result'])
                    if btn_exit.collidepoint(mouse_pos):
                        running = False

        # --- Draw Screens ---
        if state['screen'] == 'main_menu':
            screen_main_menu()
        elif state['screen'] == 'intro':
            screen_intro()
        elif state['screen'] == 'board':
            # Al dibujar el tablero, actualizamos los rects de los botones y la posición del mouse
            btn_invest, btn_inv, btn_acc, hover_room, absolute_room_pos, btn_suspects = screen_board(mouse_pos)
        elif state['screen'] == 'suspect_list':
            screen_suspect_list()
        elif state['screen'] == 'suspect_detail':
            screen_suspect_detail(state['selected_suspect'])
        elif state['screen'] == 'investigate':
            # Al dibujar, capturamos el contenido de la pista para usarlo al "Guardar evidencia"
            btn_take, btn_back, content = screen_investigate(state['selected_room'])
            current_investigation_content = content # Guardamos el texto generado
        elif state['screen'] == 'inventory':
            screen_inventory()
        elif state['screen'] == 'accuse':
            screen_accuse(state['accuse_choice'])
        elif state['screen'] == 'result':
            screen_result(*state['result'])
        
        # Lógica de fin de juego por turnos
        if state['turns'] <= 0 and state['screen'] not in ['result', 'main_menu', 'intro']:
            # Forzar el resultado de fracaso (solo si aún no hay un resultado)
            if state['result'] is None: 
                state['result'] = (False, "¡Se te acabaron los turnos! El asesino ha escapado y el caso queda sin resolver.")
            state['screen'] = 'result'

        pygame.display.flip()
        CLOCK.tick(FPS)

    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()